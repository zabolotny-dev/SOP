package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"fmt"
	"hosting-service/internal/service"

	"github.com/google/uuid"
)

// CreatePlan is the resolver for the createPlan field.
func (r *mutationResolver) CreatePlan(ctx context.Context, input CreatePlanInput) (*Plan, error) {
	plan, err := r.PlanService.Save(ctx, service.CreatePlanParams{
		Name:     input.Name,
		CPUCores: input.CPUCores,
		RAMMB:    input.RAMMb,
		DiskGB:   input.DiskGb,
	})
	if err != nil {
		return nil, err
	}
	return toGraphQLPlan(*plan), nil
}

// OrderServer is the resolver for the orderServer field.
func (r *mutationResolver) OrderServer(ctx context.Context, input OrderServerInput) (*Server, error) {
	planUUID, err := uuid.Parse(input.PlanID)
	if err != nil {
		return nil, err
	}

	server, err := r.ServerService.Save(ctx, service.CreateServerParams{
		Name:   input.Name,
		PlanID: planUUID,
	})
	if err != nil {
		return nil, err
	}

	return toGraphQLServer(*server), nil
}

// Plans is the resolver for the plans field.
func (r *queryResolver) Plans(ctx context.Context, page *int, pageSize *int) (*PlanCollection, error) {
	p, ps := 1, 10
	if page != nil {
		p = *page
	}
	if pageSize != nil {
		ps = *pageSize
	}

	result, err := r.PlanService.Search(ctx, p, ps)
	if err != nil {
		return nil, err
	}

	plans := make([]*Plan, len(result.Data))
	for i, plan := range result.Data {
		plans[i] = toGraphQLPlan(*plan)
	}

	return &PlanCollection{
		Plans:         plans,
		TotalElements: int(result.Meta.TotalCount),
		TotalPages:    int(result.Meta.TotalPages),
		CurrentPage:   int(result.Meta.Page),
		HasNextPage:   result.Meta.HasNext,
	}, nil
}

// Servers is the resolver for the servers field.
func (r *queryResolver) Servers(ctx context.Context, page *int, pageSize *int) (*ServerCollection, error) {
	p, ps := 1, 10
	if page != nil {
		p = *page
	}
	if pageSize != nil {
		ps = *pageSize
	}

	result, err := r.ServerService.Search(ctx, p, ps)
	if err != nil {
		return nil, err
	}

	servers := make([]*Server, len(result.Data))
	for i, server := range result.Data {
		servers[i] = toGraphQLServer(*server)
	}

	return &ServerCollection{
		Servers:       servers,
		TotalElements: int(result.Meta.TotalCount),
		TotalPages:    int(result.Meta.TotalPages),
		CurrentPage:   int(result.Meta.Page),
		HasNextPage:   result.Meta.HasNext,
	}, nil
}

// Plan is the resolver for the plan field.
func (r *queryResolver) Plan(ctx context.Context, id string) (*Plan, error) {
	planUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	plan, err := r.PlanService.FindByID(ctx, planUUID)
	if err != nil {
		return nil, err
	}
	return toGraphQLPlan(*plan), nil
}

// Server is the resolver for the server field.
func (r *queryResolver) Server(ctx context.Context, id string) (*Server, error) {
	serverUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	server, err := r.ServerService.FindByID(ctx, serverUUID)
	if err != nil {
		return nil, err
	}
	return toGraphQLServer(*server), nil
}

// Plan is the resolver for the plan field.
func (r *serverResolver) Plan(ctx context.Context, obj *Server) (*Plan, error) {
	planUUID, err := uuid.Parse(obj.PlanID)
	if err != nil {
		return nil, fmt.Errorf("invalid plan ID format in server object: %w", err)
	}

	planDto, err := r.PlanService.FindByID(ctx, planUUID)
	if err != nil {
		if errors.Is(err, service.ErrPlanNotFound) {
			return nil, nil
		}
		return nil, err
	}

	return toGraphQLPlan(*planDto), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Server returns ServerResolver implementation.
func (r *Resolver) Server() ServerResolver { return &serverResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type serverResolver struct{ *Resolver }
